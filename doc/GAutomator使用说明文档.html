<!DOCTYPE html>
<html>
<head>
<title>GAutomator使用说明文档</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<p><a name="GAutomator"></a></p>
<h2 id="gautomator-unity-">GAutomator Unity自动化测试教程</h2>
<ul>
<li><a href="#1">1 准备工作</a><ul>
<li><a href="#1.1">1.1 介绍</a></li><li><a href="#1.2">1.2 环境</a></li><li><a href="#1.3">1.3 使用脚本</a></li><li><a href="#1.4">1.4 GAutomatorView</a></li></ul>
</li><li><a href="#2">2 Getting</a><ul>
<li><a href="#2.1">2.1 Simple</a></li><li><a href="#2.2">2.2 实例详解</a></li><li><a href="#2.3">2.3 wetest云端兼容测试</a></li><li><a href="#2.4">2.4 本地运行</a></li></ul>
</li><li><a href="#3">3 Locating</a><ul>
<li><a href="#3.1">3.1 find_element</a></li><li><a href="#3.2">3.2 find_elements_path</a><ul>
<li><a href="#3.2.1">3.2.1 名称查找</a></li><li><a href="#3.2.2">3.2.2 子节点序列查找</a></li><li><a href="#3.2.3">3.2.3 节点中的图片名称查找</a></li><li><a href="#3.2.3">3.2.3 节点中的文字查找</a></li></ul>
</li><li><a href="#3.3">3.3 component名称查找</a></li><li><a href="#3.4">3.4 节点位置查找</a><ul>
<li><a href="#3.4.1">3.4.1 节点在屏幕上的位置</a></li><li><a href="#3.4.2">3.4.2 世界坐标获取</a></li></ul>
</li></ul>
</li><li><a href="#4">4 交互</a><ul>
<li><a href="#4.1">4.1 点击操作</a></li><li><a href="#4.2">4.2 long</a></li><li><a href="#4.3">4.3 swipe滑动</a></li><li><a href="#4.4">4.4 input输入</a></li><li><a href="#4.5">4.5 弹出框处理(获取可交互节点)</a></li><li><a href="#4.6">4.6 获取文字内容</a></li><li><a href="#4.7">4.7 获取图片名称</a></li></ul>
</li><li><a href="#5">5 Mobile设备</a><ul>
<li><a href="#5.1">5.1 屏幕尺寸与转向</a></li><li><a href="#5.2">5.2 顶层Package与Activity</a></li><li><a href="#5.3">5.3 回退键</a></li></ul>
</li><li><a href="#6">6 云端报告</a><ul>
<li><a href="#6.1">6.1 截图与操作过程标记</a></li><li><a href="#6.2">6.2 截图</a></li><li><a href="#6.3">6.3 打标签</a></li></ul>
</li><li><a href="#7">7 定制功能</a><ul>
<li><a href="#7.1">7.1 Unity游戏端注册委托</a></li><li><a href="#7.2">7.2 脚本调用</a><ul>
<li><a href="#7.2.1">7.2.1 获取可执行委托</a></li><li><a href="#7.2.2">7.2.2 执行委托</a></li><li><a href="#7.2.3">7.2.3 获取组件上的方法</a></li><li><a href="#7.2.4">7.2.4 调用组件上的方法</a></li><li><a href="#7.3">7.3 反射获取游戏中属性值</a></li><li><a href="#7.4">7.4 设置最佳渲染Camera</a></li></ul>
</li></ul>
</li><li><a href="#8">8 实战用例</a><ul>
<li><a href="#8.1">8.1 摇杆</a></li><li><a href="#8.2">8.2 记录操作流程</a></li><li><a href="#8.3">8.3 QQ或微信登录</a></li><li><a href="#8.4">8.4 战斗场景随机操作</a></li><li><a href="#8.5">8.5 选区操作</a></li><li><a href="#8.6">8.6 自动化探索遍历</a></li><li><a href="#8.7">8.7 异常处理</a></li></ul>
</li><li><a href="#9">9 实际使用接口</a><ul>
<li><a href="#9.1">9.1 screen_shot_click</a></li><li><a href="#9.2">9.2 screen_shot_click_pos</a></li><li><a href="#9.3">9.3 find_elment_wait查找控件直到出现位置</a></li><li><a href="#9.4">9.4 wait_for_scene等待某个场景加载完毕</a></li></ul>
</li></ul>
<p><strong>GAutomator</strong> 通过Python实现Unity手游的UI自动化测试，强烈建议使用pycharm编辑python。可在<a href="http://wetest.qq.com/cloud/index.php/phone/blrooike下载所有需要的所有组件。">http://wetest.qq.com/cloud/index.php/phone/blrooike下载所有需要的所有组件。</a></p>
<p><a name="1"></a></p>
<h1 id="1-">1 准备工作</h1>
<p><a name="1.1"></a></p>
<h2 id="1-1-">1.1 介绍</h2>
<p>通过Python实现Unity手游的UI自动化测试。GAutomator测试运行在手机端，通过adb操控手机上的unity手游，支持所有版本的Android手机。这个工具的主要功能包括：测试与Android手机之间的兼容性--测试手游在不同Android手机上的工作情况。功能性测试，PVP游戏可以自动化测试代替人力节省操作，PVE游戏可以自动大关完成冒烟测试。性能测试，云端测试能够手机CPU、内存、流量和FPS数据，能够标记不同的场景。</p>
<p><a name="1.2"></a></p>
<h2 id="1-2-">1.2 环境</h2>
<p><strong>1 python</strong>: python 2.7</p>
<p><strong>2 adb</strong><br>请确保，你的path环境变量里面设置了adb<br>在cmd命令行里面输入adb devices，能够看到你的手机序列号</p>
<p><a name="1.3"></a></p>
<h2 id="1-3-">1.3 使用脚本</h2>
<p>如果使用pycharm的话，直接打开scripts功能即可进行编辑使用</p>
<p><img src="image/pycharm_step1.png" alt="Drawing" width="300px" /><br><img src="image/pycharm_step2.png" alt="Drawing" width="300px" /></p>
<p>可以在testcase目录下面直接创建你需要的.py脚本，然后编写需要的逻辑</p>
<p><a name="1.4"></a></p>
<h2 id="1-4-gautomatorview">1.4 GAutomatorView</h2>
<p>GAutomatorView工具可在<a href="http://wetest.qq.com/cloud/index.php/phone/blrooike下载">http://wetest.qq.com/cloud/index.php/phone/blrooike下载</a> 。GAutomator主要根据，Unity游戏中的GameObject的路径名称来编写逻辑。类似于UIAutomator需要有一个，控件查看器；GAutomator也提供了一款类似的，Unity游戏中控件查看器。<br><strong>注：请勿将该软件放置在中文目录下</strong></p>
<p><img src="image/behaviour.png" alt="Drawing" width="800px" /></p>
<p>集成wetest sdk的游戏拉起后，点击同步按钮，就能获取到游戏界面和控件树</p>
<p><a name="2"></a></p>
<h1 id="2-getting-started">2 Getting Started</h1>
<p>示例代码：sample/sample.py,示例apk游戏:sampel/wetest_demo.apk</p>
<p><a name="2.1"></a></p>
<h2 id="2-1-simple-usage">2.1 Simple Usage</h2>
<p>已经安装好python及依赖库后，可以使用pycharm（请下社区版，社区版免费）直接打开工程，你可以下面的代码开始我们的测试</p>
<pre><code class="lang-python">
#import lib path,only use in this demo
#import sys,os
#sys.path.append(os.path.abspath(os.path.join(os.getcwd(), &quot;..\\&quot;)))

import wpyscripts.manager as manager

def test():
    engine=manager.get_engine()
    logger=manager.get_logger()

    version=engine.get_sdk_version()
    logger.debug(&quot;Version Information : {0}&quot;.format(version))

    scene=engine.get_scene()
    logger.debug(&quot;Scene :   {0}&quot;.format(scene))

    sample_button=engine.find_element(&quot;/Canvas/Panel/Sample&quot;)
    logger.debug(&quot;Button : {0}&quot;.format(sample_button))
    engine.click(sample_button)

test()
</code></pre>
<p>上面的代码可以保存为sample.py,然后运行</p>
<pre><code class="lang-bat">python samle.py
</code></pre>
<p>请确保，wetestdemo游戏已经拉起，wpyscripts库能够查找到</p>
<p><a name="2.2"></a></p>
<h2 id="2-2-">2.2 实例详解</h2>
<p>wpyscripts.manager模块提供了自动化测试所需的所有功能，提供与引擎、手机、报告相关的内容，也提供了日志实现</p>
<pre><code class="lang-python">import wpyscripts.manager as manager
</code></pre>
<p>下一步，创建Engine和日志实例</p>
<pre><code class="lang-python">engine=manager.get_engine()
logger=manager.get_logger()
</code></pre>
<p><em><code>engine.get_sdk_version()</code></em>能够获取Unity版本信息、Wetest sdk版本信息，能够获取该信息时，证明脚本已经成功连上游戏。如果获取失败，则会抛出<code>WeTestNativeEngineDllError</code>异常,抛出该异常可能是手机USB线没有连好或者手机开发者选项未打开。<br><em>logger.debug(&quot;&quot;)</em>输出对应日志，请使用manager.get_logger()获取的实例，避免脚本在云端<a href="http://wetest.qq.com" title="wetest">wetest.qq.com</a>使用时出错。</p>
<pre><code class="lang-python">version=engine.get_sdk_version()
logger.debug(&quot;Version Information : {0}&quot;.format(version))
</code></pre>
<p><em><code>engine.get_scene()</code></em>获取当前游戏界面对应scene名称，wetestdemo游戏的第一个界面名称为main</p>
<p><img src="image/scene.png" alt="Drawing" width="600px" /></p>
<p><em><code>engine.find_element(&quot;/Canvas/Panel/Sample&quot;)</code></em>查找当前界面中路径为/Canvas/Panel/Sample的节点，如果存在则返回Element，不存在则返回None。find_element直接使用Unity <a href="http://docs.unity3d.com/ScriptReference/GameObject.Find.html?from=index">GameObject.Find</a>查找当前游戏中的game object。<br>查找到的节点samle_button（<em>Element</em>），有两个属性object_name,instance。object_name是节点的全路径，instance是节点实例的编号（GameObject.GetInstanceID()获取）instance在当前游戏中一定是唯一的。<br><em><code>engine.click(sample_button)</code></em>尝试点击samle_button这个GameObject的中心点。</p>
<pre><code class="lang-python">sample_button=engine.find_element(&quot;/Canvas/Panel/Sample&quot;)
logger.debug(&quot;Button : {0}&quot;.format(sample_button))
engine.click(sample_button)
</code></pre>
<p>wpyscripts包含4大接口</p>
<pre><code class="lang-python">engine=manager.get_engine()
reporter=manager.get_reporter()
device=manager.get_devcie()
logger=manager.get_logger()
</code></pre>
<ul>
<li>engine:Unity相关内容，主要包括控件获取，游戏操作</li><li>reporter:云端报告相关，截图、标记操作过程、性能数据打标签</li><li>device:手机设备相关，如屏幕长宽高、转向，也包括QQ登录等。</li><li>logger:日志输出接口，保证本地与云端输出的日志都能获取到</li></ul>
<p><a name="2.3"></a></p>
<h2 id="2-3-wetest-">2.3 wetest云端兼容测试</h2>
<p>wpyscripts编写好的测试脚本，只需要非常简单的修改，就能wetest云端上做兼容测试。云端几千台手机，按照脚本执行游戏。wetest能够发现兼容问题，同时高度还原执行现场，包括手机日志、崩溃信息、截图、执行过程等。</p>
<p>云端执行脚本时，会执行testcase.runner下的run函数，只需要把自己的业务逻辑加入到这个函数中即可</p>
<pre><code class="lang-python">import traceback

try:
    from sample.sample import *
except Exception,e:
    traceback.print_exc()

def run():
    &quot;&quot;&quot;
        业务逻辑的起点
    &quot;&quot;&quot;
    try:
        test()
    except Exception,e:
        traceback.print_exc()
</code></pre>
<p>然后，运行scripts目录下的，build.py<br><code>python build.py</code><br>会在scripts目录下产生一个,wpyscripts_upload.zip。只有企业用户才可以使用云端测试，请登录wetest.qq.com，联系工作人员了解详情。</p>
<p><img src="image/step1.png" alt="Drawing" width="400px" /><br><img src="image/step2.png" alt="Drawing" width="400px" /><br><img src="image/step3.png" alt="Drawing" width="400px" /></p>
<p><a name="2.4"></a></p>
<h2 id="2-4-">2.4 本地运行</h2>
<p><strong>注：调试时手动启动游戏，运行到指定界面，运行对应的脚本即可，如调试大厅界面的代码，游戏跑到大厅界面，再运行自动化测试逻辑。不需要从main.py启动</strong><br>GAutomator支持一台PC在多台android手机上同时测试。首先需要设置游戏的包名，在main.py开头处，进行修改设置local_package。</p>
<pre><code class="lang-python">local_package = os.environ.get(&quot;PKGNAME&quot;, &quot;&quot;)  # 你需要测试的包名,可以设置默认值

#local_package =&quot;com.tencent.wetest.demo&quot;
</code></pre>
<p>一般一个工程通过main方式启动，只能测试一个游戏，所以直接在main.py里面写死，也避免参数传入的麻烦。<br>1、测试一台手机，如果PC上USB只连接一台手机，直接启动main.py即可</p>
<pre><code class="lang-bat">python main.py
</code></pre>
<p>2、测试多台手机，如果PC上USB连接超过一台手机，需要通过命令行的方式启动</p>
<pre><code class="lang-bat">adb devices #查看当前手机序列号

saaaweadf        device
asdfadfadf         device
</code></pre>
<p>获取到当前PC连接的手机序列号之后，通过命令行的方式控制脚本在指定的手机上进行测试。</p>
<pre><code class="lang-bat">python main.py --qqname=2952020110 --qqpwd=wetestpwd --engineport=50031 --uiport=19000 --serial=saaaweadf
python main.py --qqname=2952020111 --qqpwd=wetestpwd --engineport=50032 --uiport=19001 --serial=asdfadfadf
</code></pre>
<p>上面的命令分别代表，在序列号&quot;saaaweadf&quot;手机上测试，测试时使用的QQ号为2952020110,密码为wetestpwd，与引擎建立映射的网络端口号为50031,与UIAutomator服务建立映射的网络端口为19000。第二条命令类似。</p>
<p><strong>命令行参数含义</strong>如下：</p>
<pre><code class="lang-bat">--qqname:qq账号，每部手机应该都不一样
--qqpwd:qq密码
--wechataccount:微信账号
--wechatpwd:微信密码
--othername:其他任何账号
--otherpwd:其他任何账号的密码
--engineport:与手机端的sdk服务建立网络映射，填入的为本地的网络端口号（如,50031），不同手机之间要确保不同
--uiport:与手机端的UIAutomator服务建立网络映射，填入的为本地的网络端口号（如,19008），不同手机之间要确保不同
--serial:adb devcies能够查看手机的序列号，不同的序列号代表不同的手机
</code></pre>
<p><a name="3"></a></p>
<h1 id="3-locating-elements">3 Locating Elements</h1>
<p>engine模块提供了三种GameObject的查找方式。示例：sample/find_elements.py</p>
<ul>
<li><em>find_element</em></li><li><em>find_elements_path</em></li><li><em>find_elements_by_component</em></li></ul>
<p><a name="3.1"></a></p>
<h2 id="3-1-find_element">3.1 find_element</h2>
<p><em>find_element</em>通过Unity的GameObject.Find()方法查找游戏中的的gameobject。<em>find_element</em>通过GameObject的名称查找对象，名字中可以包含&#39;/&#39;代表GameObject树中的一层。这方法只返回当前激活(active)的gameobject。<br>当界面上有两个一模一样路径的gameobject时，只返回其中的一个。代码示例：</p>
<pre><code class="lang-python">#import sys,os,time
#sys.path.append(os.path.abspath(os.path.join(os.getcwd(), &quot;..\\&quot;)))

import wpyscripts.manager as manager
def test_find_element():
    button=engine.find_element(&quot;/Canvas/Panel/Button&quot;)
    bound=engine.get_element_bound(button)
    logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(button,bound))
    engine.click(button)

    button=engine.find_element(&quot;Button&quot;)
    bound=engine.get_element_bound(button)
    logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(button,bound))
    engine.click(button)

    button=engine.find_element(&quot;Panel/Button&quot;)
    bound=engine.get_element_bound(button)
    logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(button,bound))
    engine.click(button)

    unexited_gameobj=engine.find_element(&quot;Test&quot;)
    if unexited_gameobj is None:
        logger.debug(&quot;Test GameObject not find&quot;)

test_find_element()
</code></pre>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<pre><code class="lang-bat">python find_elments.py
</code></pre>
<p><img src="image/find_elements_scene.png" alt="Drawing" width="400px" /></p>
<pre><code class="lang-xml">&lt;GameObject name=&quot;WetestSDK&quot; components=&quot;U3DAutomationBehaviour&quot; id=&quot;10064&quot; /&gt;
&lt;GameObject name=&quot;Control&quot; components=&quot;gobal&quot; id=&quot;10074&quot; /&gt;
&lt;GameObject name=&quot;EventSystem&quot; components=&quot;EventSystem|StandaloneInputModule|TouchInputModule&quot; id=&quot;10196&quot; /&gt;
&lt;GameObject name=&quot;Canvas&quot; components=&quot;Canvas|CanvasScaler|GraphicRaycaster|AudioListener&quot; id=&quot;10188&quot;&gt;
  &lt;GameObject name=&quot;bg&quot; components=&quot;CanvasRenderer|Image&quot; id=&quot;10198&quot; img=&quot;Background&quot;&gt;
    &lt;GameObject name=&quot;RawImage&quot; components=&quot;CanvasRenderer|RawImage&quot; id=&quot;10194&quot; img=&quot;find_bg&quot; /&gt;
  &lt;/GameObject&gt;
  &lt;GameObject name=&quot;Panel&quot; components=&quot;CanvasRenderer|FindElementsControl&quot; id=&quot;10192&quot;&gt;
    &lt;GameObject name=&quot;Button&quot; components=&quot;CanvasRenderer|Image|Button|EventTriggerListener&quot; id=&quot;10182&quot; img=&quot;bt_bg&quot;&gt;
      &lt;GameObject name=&quot;Text&quot; components=&quot;CanvasRenderer|Text&quot; id=&quot;10186&quot; txt=&quot;Button&quot; /&gt;
    &lt;/GameObject&gt;
    &lt;GameObject name=&quot;Back&quot; components=&quot;CanvasRenderer|Image|Back|EventTriggerListener&quot; id=&quot;10190&quot; img=&quot;back&quot; /&gt;
    &lt;GameObject name=&quot;Button&quot; components=&quot;CanvasRenderer|Image|Button&quot; id=&quot;10200&quot; img=&quot;bt_bg&quot;&gt;
      &lt;GameObject name=&quot;Text&quot; components=&quot;CanvasRenderer|Text&quot; id=&quot;10184&quot; txt=&quot;Button&quot; /&gt;
    &lt;/GameObject&gt;
  &lt;/GameObject&gt;
&lt;/GameObject&gt;
</code></pre>
<p>运行时符合&quot;/Canvas/Panel/Button&quot;的节点有两个，但是每次都是节点的第一个。如果查找的节点不存在，则返回None</p>
<p><a name="3.2"></a></p>
<h2 id="3-2-find_elements_path">3.2 find_elements_path</h2>
<p><em>find_elements_path</em>能够一次查找到多个符合的gameobject。但是<em>find_elements</em>是一个<strong>非常耗时的操作需要谨慎使用</strong>，对测试时的性能数据有一定影响（主要是fps值）。<em>find_elments</em>通过表达式查找gameobject,查找条件为（查找条件为与，只要出现就一定要满足）：</p>
<ul>
<li>gameobject路径</li><li>gameobject在节点中的位置，顺序(第一个节点为0)</li><li>gameobject包含图片组件时的图片名称</li><li>gameobject包含文字组件时的文字内容<br><strong><em>注：不能确保返回结果的顺序</em></strong></li></ul>
<p><a name="3.2.1"></a></p>
<h3 id="3-2-1-">3.2.1 名称查找</h3>
<pre><code class="lang-python">def test_find_elements_by_name():
    elements = engine.find_elements_path(&quot;/Canvas/Panel/VerticalPanel/Item(Clone)&quot;)
    for element in elements:
        bound=engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))
        engine.click(bound)
        time.sleep(0.5)
test_find_elements_by_name()
</code></pre>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<pre><code class="lang-bat">python find_elments.py
</code></pre>
<p><em>find_elements_path</em>能够返回所有符合的节点</p>
<p><img src="image/find_elments_xml.png" alt="Drawing" width="800px" /></p>
<p>返回结果</p>
<pre><code class="lang-xml">GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10080
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10104
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10128
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10152
GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -10176
</code></pre>
<p>关卡列表，除了<em>/Canvas/Panel/VerticalPanel/Item(Clone)</em>符合之外，也可以是其他表达式。</p>
<pre><code class="lang-python">_elements = engine.find_elements_path(&quot;Panel/VerticalPanel/Item(Clone)&quot;)
_elements = engine.find_elements_path(&quot;VerticalPanel/Item(Clone)&quot;)
_elements = engine.find_elements_path(&quot;Item(Clone)&quot;)
_elements = engine.find_elements_path(&quot;/Canvas/Panel/*/Item(Clone)&quot;)
</code></pre>
<ul>
<li><code>Panel/VerticalPanel/Item(Clone)</code>，表示查找节点Item(Clone)，且父亲节点为VerticalPanel，祖父节点Panel</li><li><code>VerticalPanel/Item(Clone)</code>，表示查找节点Item(Clone)，且父亲节点为VerticalPanel</li><li><code>Item(Clone)</code>，表示查找所有名叫Item(Clone)的节点</li><li><code>/Canvas/Panel/*/Item(Clone)</code>，表示查找节点Item(Clone)，任意父亲节点，祖父节点为Panel,曾祖父节点为Canvas且为根节点。其中*表示任意名称。</li></ul>
<p><strong><em>find_elments_path</em></strong>接口非常耗时。</p>
<p><a name="3.2.2"></a></p>
<h3 id="3-2-2-">3.2.2 子节点序列查找</h3>
<p>如果只想选择关卡2，不想返回所有的节点。可以利用<em>find_elements_path</em>中的序列来进行查找定位。序列的表达式为[num],num为数字从0开始</p>
<pre><code class="lang-python">def test_find_elements_by_index():
    elements = engine.find_elements_path(&quot;/Canvas/Panel/VerticalPanel/*[1]&quot;)
    for element in elements:
        bound=engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))
        engine.click(bound)
        time.sleep(0.5)

    elements=engine.find_elements_path(&quot;/Canvas/Panel/VerticalPanel/Button[0]&quot;)
    assert elements == []
test_find_elements_by_index()
</code></pre>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<pre><code class="lang-bat">python find_elments.py
</code></pre>
<p><em>find_elements_path</em>能够返回所有符合的节点,这个脚本中会返回关卡2，并进行点击</p>
<ul>
<li>/Canvas/Panel/VerticalPanel/*[1]，表示查找VericalPanel节点中的第二个子节点，VericalPanel的父节点为Panel,Panel的父节点为Cavnvas，且Canvas为根节点</li><li>/Canvas/Panel/VerticalPanel/Button[0]，表示查找VericalPanel节点中第一个子节点，<strong>且名为Button</strong>,VericalPanel的父节点为Panel,Panel的父节点为Cavnvas，且Canvas为根节点<br><strong>注：序列从0开始，0表示第一个子节点；序列[num]与名字的关系是与，需要都符合，如果是任意名称请用*</strong>。根节点不能使用[]，[]是相对于父亲节点的位置，所以根节点不存在父节点。</li></ul>
<p><a name="3.2.3"></a></p>
<h3 id="3-2-3-">3.2.3 节点中的图片名称查找</h3>
<p><em>find_elements_path</em>能够根据节点的图片名称进行查找。表达式为{img=imageName}，img为图片名称</p>
<pre><code class="lang-python">def test_find_elements_by_img():
    elements = engine.find_elements_path(&quot;/Canvas/Panel/Image{img=saturn}&quot;)
    for element in elements:
        bound=engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))
        engine.click(bound)
        time.sleep(0.5)
    engine.click_position(100,200)
    elements = engine.find_elements_path(&quot;/Canvas/Panel{img=saturn}&quot;)
    for element in elements:
        bound=engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))
test_find_elements_by_img()
</code></pre>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<pre><code class="lang-bat">python find_elments.py
</code></pre>
<p><img src="image/find_elments_xml_img.png" alt="Drawing" width="800px" /></p>
<p>运行结果如下，<em>/Canvas/Panel/Image{img=saturn}</em>和<em>/Canvas/Panel{img=saturn}</em>均能找到指定的节点</p>
<pre><code class="lang-xml">Button : GameObject /Canvas/Panel/Image Instance = 10218,Bound : point(1461.0,81.0) width = 352.0 height = 341.0
Button : GameObject /Canvas/Panel Instance = 10222,Bound : point(0.0,0.0) width = 1920.0 height = 1080.5
</code></pre>
<ul>
<li><code>/Canvas/Panel/Image{img=saturn}</code>,表示查找Image节点（且Image节点或者子节点包含saturn图片），Image父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li><li><code>/Canvas/Panel{img=saturn}</code>,表示查找Panel节点（且Panel节点或者子节点包含saturn图片）,Panel父节点为Canvas,且Canvas为根节点</li></ul>
<p>img代表的是图片名称，Unity游戏中哪些组件符合这边的名称呢？</p>
<ul>
<li>UGUI,wetest sdk会搜索Image、RawImage、SpriteRender中的图片</li><li>NGUI，wetest sdk会搜索UISprite、UITexture、Renderer中的图片</li></ul>
<p>为什么要搜索节点及其所有子节点？Unity制作的时候，往往会在可交互节点下面挂载图片文字等。这样做的目的是为了尽可能测试人员方便查找。</p>
<p><a name="3.2.3"></a></p>
<h3 id="3-2-3-">3.2.3 节点中的文字查找</h3>
<p><em>find_elements_path</em>能够根据节点及子节点中文字内容进行查找。表达式为{txt=txtName}，txtName为文字内容</p>
<pre><code class="lang-python">def test_find_elements_by_txt():
    elements=engine.find_elements_path(&quot;Panel/VerticalPanel/Item(Clone){txt=关卡2}&quot;)
    for element in elements:
        bound=engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))
        engine.click(bound)
        time.sleep(0.5)

    elements=engine.find_elements_path(&quot;Panel/VerticalPanel/Item(Clone){txt=关卡4}&quot;)
    if len(elements) &gt; 0:
        engine.click(elements[0])
test_find_elements_by_txt()
</code></pre>
<p>上面的代码可以保存为find_elments.py,从wetestdemo点击FindElements，然后运行</p>
<pre><code class="lang-bat">python find_elments.py
</code></pre>
<p><img src="image/find_elments_xml_txt.png" alt="Drawing" width="600px" /></p>
<p>运行结果如下，<em>Item(Clone){txt=关卡2}</em>和<em>Panel/VerticalPanel/Item(Clone){txt=关卡4}</em>均能找到指定的节点</p>
<pre><code class="lang-xml">Button : GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -11784,Bound : point(1420.0,710.5) width = 500.0 height = 80.0
Button : GameObject /Canvas/Panel/VerticalPanel/Item(Clone) Instance = -11832,Bound : point(1420.0,870.5) width = 500.0 height = 80.0
</code></pre>
<ul>
<li><code>Panel/VerticalPanel/Item(Clone){txt=关卡2}</code>,表示查找Item(Clone)节点（且Item(Clone)节点或者其子节点，包含文字&quot;关卡2&quot;），Item(Clone)父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li><li><code>Panel/VerticalPanel/Item(Clone){txt=关卡4}</code>,表示查找Item(Clone)节点（且Item(Clone)节点或者其子节点，包含文字&quot;关卡4&quot;），Item(Clone)父节点为Panel,Panel父节点为Canvas,且Canvas为根节点</li></ul>
<p>txt代表的是文字内容，寻找匹配时，会从以下节点查找问题内容</p>
<ul>
<li>UGUI，wetest sdk会搜索组件Text、GUIText中的内容</li><li>NGUI，wetest sdk会搜索组件UILabel、UIInput和GUIText中的内容</li></ul>
<p><a name="3.3"></a></p>
<h2 id="3-3-component-">3.3 component名称查找</h2>
<p>根据Unity中Component的名称查找，Gameobject。本质上调用的是Unity中的GameObject.FindObjectsOfType(Type.GetType(name))接口。C#里面Type.GetType传入的，应该是AssemblyQualifiedName。所以，下面的例子中传入的是&quot;UnityEngine.UI.Button,UnityEngine.UI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;，如果传入的是Button返回为空</p>
<pre><code class="lang-python">def test_find_elements_by_component():
    elements=engine.find_elements_by_component(&quot;UnityEngine.UI.Button,UnityEngine.UI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;)
    for element in elements:
        bound = engine.get_element_bound(element)
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element, bound))
        engine.click(bound)
        time.sleep(0.5)

test_find_elements_by_component()
</code></pre>
<p><a name="3.4"></a></p>
<h2 id="3-4-">3.4 节点位置查找</h2>
<p><a name="3.4.1"></a></p>
<h3 id="3-4-1-">3.4.1 节点在屏幕上的位置</h3>
<p><em>engine.get_element_bound(element)</em>能够获取节点在屏幕中的位置。wpyscripts所有的操作都是通过触屏进行的，因此获取节点在屏幕上的位置是进行交互操作的基石。</p>
<pre><code class="lang-python">def test_click():
    #点击节点
    element=engine.find_element(&quot;/Canvas/Panel/Click&quot;)
    bound=engine.get_element_bound(element)
    logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))

    engine.click(bound)
    time.sleep(1)
    engine.click(element)

    time.sleep(2)
    engine.click_position(600.0,100.0)

test_click()
</code></pre>
<pre><code>Button : GameObject /Canvas/Panel/Click Instance = 10652,Bound : point(535.0,60.0) width = 250.0 height = 80.0
</code></pre><p><code>engine.get_element_bound(Element)</code>获取的是ElementBound，获取Element的左上角在屏幕上的坐标，和Element的长宽高。遵循的是手机的坐标系，以左上角为坐标原点，上下边框为width，左右为height。</p>
<p><img src="image/interaction_click.png" alt="Drawing" width="400px" /><br><img src="image/portrait.png" alt="Drawing" width="300px" /></p>
<p><a name="3.4.2"></a></p>
<h3 id="3-4-2-">3.4.2 世界坐标获取</h3>
<p>手游越来越重度化，3D手游越来越普及，对于3D手游而言仅仅是屏幕坐标已经无法满足自动化测试的需求。对于王者荣耀、全民超神这种类型的手游，自动化测试过程中需要知道自己、敌方和队友英雄在地图上的位置，才能编写出想要的自动化功能（如移动英雄到某个位置、发现敌方英雄攻击等）。所以在wpyscripts v 1.1.1版本，WeTest SDK 8版本，推出了get_element_world_bound(elements)，能够获取节点的世界坐标系。<strong>示例位置sample/joystick_tester.py 中的test_world_bounds()</strong></p>
<pre><code class="lang-python">def test_world_bounds():
    person=engine.find_element(&quot;/3rd Person Controller/Bip001/Bip001 Pelvis&quot;)
    world_bound=engine.get_element_world_bound(person)
    logger.debug(world_bound[0])

test_world_bounds()
</code></pre>
<p>以上代码，需要在wetest_demo.apk点击Joystick，进入Joystick界面后运行才有效</p>
<pre><code class="lang-bat">python joystick_tester.py
</code></pre>
<p>结果如下：</p>
<pre><code class="lang-xml">center = (5.03773808305e-05,0.1374322474,0.00151373702101) extents =(0.0807622969151,0.09486310184,0.0181320905685)
</code></pre>
<p>返回查询的所有Element的对应世界坐标，WorldBound[]。WorldBound是节点在Unity世界坐标系中的各项值，主要包括中心点的x,y,z坐标值，及中心点距物体在x,y,z轴方向上的距离。具体可参考：Unity官网Bounds介绍<a href="http://docs.unity3d.com/ScriptReference/Bounds.html">http://docs.unity3d.com/ScriptReference/Bounds.html</a></p>
<p><a name="4"></a></p>
<h1 id="4-">4 交互</h1>
<p>找到节点后的第一件后，就需要对寻找到的节点进行操作。示例：sample/interaction.py</p>
<pre><code class="lang-python">engine.click(button)
</code></pre>
<p>Engine执行操作后，会立马返回，不会等button按钮相应完成才返回。engine.click(Element)返回为True的话，只保证执行了button中心点的点击事件，不能确保button对应的事件被有效执行（有弹出框，遮住的情况就可能使点击无效）。</p>
<p><img src="image/interaction_mask.png" alt="Drawing" width="400px" /></p>
<p><a name="4.1"></a></p>
<h2 id="4-1-">4.1 点击操作</h2>
<p><em>engine.click()</em>允许传入Element和ElementBound。如果传入的是Element，会先去查找ElementBound,然后再计算出节点的中心位置进行点击。所以，在有ElementBound的情况下，应该首先传入ElementBound。</p>
<pre><code class="lang-python">def test_click():
    #点击节点
    element=engine.find_element(&quot;/Canvas/Panel/Click&quot;)
    bound=engine.get_element_bound(element)
    logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(element,bound))

    engine.click(bound)
    time.sleep(1)
    engine.click(element)

    time.sleep(2)
    engine.click_position(600.0,100.0)

test_click()
</code></pre>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<pre><code class="lang-bat">python interaction.py
</code></pre>
<p>程序会连续点击3下，Click按钮。</p>
<ul>
<li><code>engine.click(bound)</code>会点击，Click的中心节点(point.x+withd/2,point.y+height/2)</li><li><code>engine.click(element)</code>首先回去查找element节点的ElementBound，然后计算出中心点，在进行点击</li><li><code>engine.click_position(600.0,100.0)</code>直接点击屏幕坐标为(600.0,100.0)的坐标。<strong>手机屏幕尺寸发生变化，点击将无效，不能点击到期望位置</strong></li></ul>
<p><a name="4.2"></a></p>
<h2 id="4-2-long-press-">4.2 long press长按</h2>
<p><em>engine.press()和engine.press_position</em>与click相似，多一个时间参数，表示长按的时间（单位ms,毫秒）</p>
<pre><code class="lang-python">def test_press():
    element=engine.find_element(&quot;/Canvas/Panel/Press&quot;)
    engine.press(element,5000)
    time.sleep(2)
    engine.press_position(1200,100,3000)

test_press()
</code></pre>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<pre><code class="lang-bat">python interaction.py
</code></pre>
<ul>
<li><code>engine.press(element,5000)</code>,<code>/Canvas/Panel/Press</code>节点连续按住5s</li><li><code>ngine.press_position(1200,100,3000)</code>,(1200,100)点，连续按住3s</li></ul>
<p><a name="4.3"></a></p>
<h2 id="4-3-swipe-">4.3 swipe滑动</h2>
<p><em>engine.swipe(start_element, end_element, steps, duration=1000)和engine.swipe_position(start_x,start_y,end_x,end_y,steps, duration=1000)</em>，可以从一个节点滑动到另外一个节点，通过设置滑动步骤来控制滑动的平滑度和滑动速度。duration以毫秒为单位，为滑动的时长。滑动时长不能不能精确控制，只是尽可能接近。滑动由Touch触屏操作的Down-&gt;move-&gt;move...-&gt;up组合而成，steps指的是move的数量，一般指的是滑动的平滑度。<em>swipe与swipe_position</em>动作执行完之后返回，由SDK负责执行动作，不能并行的执行动作。如下面的示例中，第一个动作执行完后，才会执行第二个动作。</p>
<pre><code class="lang-python">def test_swipe():
    start_e=engine.find_element(&quot;/Canvas/Panel/Press&quot;)
    end_e=engine.find_element(&quot;/Canvas/Panel/Click&quot;)
    engine.swipe(start_e,end_e,50,2000)

    silder=engine.find_element(&quot;/Canvas/Panel/Slider&quot;)
    if silder:
        bound=engine.get_element_bound(silder)
        engine.swipe_position(bound.x,bound.y+bound.height/2.0,bound.x+bound.width,bound.y+bound.height/2,100,3000)
test_swipe()
</code></pre>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<pre><code class="lang-bat">python interaction.py
</code></pre>
<p>从Press的中心点按钮按下，一直Move到Click的中心点，中间经过50步，最后执行Up动作，持续时长大致为2秒</p>
<pre><code>start_e=engine.find_element(&quot;/Canvas/Panel/Press&quot;)
end_e=engine.find_element(&quot;/Canvas/Panel/Click&quot;)
engine.swipe(start_e,end_e,50,2000)
</code></pre><p>无论swipe的步长设置为多少，都会立刻返回。立刻执行swipe_position函数，swipe_position也需要动作执行完之后才会返回，但是游戏中还不会马上执行这个动作。需要swipe执行完成后，才会执行swipe_position的动作。</p>
<pre><code>silder=engine.find_element(&quot;/Canvas/Panel/Slider&quot;)
if silder:
   bound=engine.get_element_bound(silder)
   engine.swipe_position(bound.x,bound.y+bound.height/2.0,bound.x+bound.width,bound.y+bound.height/2,100,3000)
</code></pre><p><a name="4.4"></a></p>
<h2 id="4-4-input-">4.4 input输入</h2>
<p><em>engine.input(Element,txt)</em>设置input里面的文字内容</p>
<pre><code class="lang-python">def test_input():
    element=engine.find_element(&quot;/Canvas/Panel/InputField&quot;)
    engine.input(element,&quot;Run Wpy&quot;)

test_input()
</code></pre>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<pre><code class="lang-bat">python interaction.py
</code></pre>
<p>运行后，文本框里面的内容从<em>Hello wpyscripts</em>变成<em>Run Wpy</em>。</p>
<ul>
<li>UGUI,Element必须包含InputField组件</li><li>NGUI，Element必须包含UILabel组件</li></ul>
<p><a name="4.5"></a></p>
<h2 id="4-5-">4.5 弹出框处理(获取可交互节点)</h2>
<p>所有的交互操作，只能保证屏幕上有这些时间。列如下图，点击Click按钮，只确保在屏幕Click按钮的位置按了一下，不确保Click按钮有效果，因为这个时候有弹出框遮住了Click按钮。<br><img src="image/interaction_mask.png" alt="Drawing" width="400px" /><br>游戏运行过程中，因为等级、公告、网络等各种原因可能会出现弹出框，这个时候原本的测试逻辑将无法继续运行。engine.get_touchable_elements()可以返回当前可点击的节点。</p>
<pre><code class="lang-python">def test_get_touchable_elements():
    e=engine.find_element(&quot;/Canvas/Panel/Close&quot;)
    engine.click(e)

    elements=engine.get_touchable_elements()
    for e,pos in elements:
        logger.debug(&quot;Button : {0},Bound : {1}&quot;.format(e,pos))

    time.sleep(2)
    engine.click_position(elements[0][1][&quot;x&quot;],elements[0][1][&quot;y&quot;])

test_get_touchable_elements()
</code></pre>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<pre><code class="lang-bat">python interaction.py
</code></pre>
<p>运行后，返回当前可点击的有效节点及他们的位置</p>
<pre><code>Button : GameObject /Canvas/Dialog(Clone)/Sure Instance = 4294957156,Bound : {&#39;y&#39;: 733.0, &#39;x&#39;: 660.0}
Button : GameObject /Canvas/Dialog(Clone)/Cancel Instance = 4294957136,Bound : {&#39;y&#39;: 733.0, &#39;x&#39;: 1260.0}
</code></pre><p>上图返回的就是，Confirm和Canel两个按钮。这两个按钮是有效的可交互的按钮（按下去会有反应的），其他红色圈出来的回退、Click、Press和Close都已经被遮住，在这个位置点击也是无效的。<br><em><code>engine.get_touchable_elements()</code></em>是一个相对耗时的接口，一般腾讯常见的游戏，耗时在80ms以内（在一帧内处理）。返回的是一个元组列表，元组中包含可交互的有效节点和位置（一个x,y的字典），所以无需再请求节点位置，可以直接点击。</p>
<p><a name="4.6"></a></p>
<h2 id="4-6-">4.6 获取文字内容</h2>
<p>可以获取到游戏中的文字内容。NGUI能够获取到UILable、UIInput、GUIText组件上的文字内容，如果GameObject上不包含以上组件，将抛出异常。UGUI能够获取Text、GUIText组件上的文字信息。示例在interaction.py中，wetest_demo.apk需要在interaction界面。</p>
<pre><code class="lang-python">def test_get_element_txt():
    e=engine.find_element(&quot;Click/Text&quot;)
    text=engine.get_element_text(e)
    logger.debug(&quot;Text = {0}&quot;.format(text))
</code></pre>
<p>上面的代码在sample/interaction.py中，运行该函数可以获取文字内容&quot;Click&quot;</p>
<p><a name="4.7"></a></p>
<h2 id="4-7-">4.7 获取图片名称</h2>
<p>可以获取到游戏中的GameObject上面对应的图片名称。NGUI取UITexture、UISprite、SpriteRenderer组件上的图片名称，如果GameObject上不包含以上组件，将抛出异常。UGUI能够获取Image、RawImage、SpriteRenderer组件上的图片名称。示例在interaction.py中，wetest_demo.apk需要在interaction界面。</p>
<pre><code class="lang-python">def test_get_element_image():
    e = engine.find_element(&quot;Back&quot;)
    image = engine.get_element_image(e)
    logger.debug(&quot;Image = {0}&quot;.format(image))
</code></pre>
<p>上面的代码在sample/interaction.py中，运行该函数可以获取图片名称&quot;back&quot;</p>
<p><a name="5"></a></p>
<h1 id="5-mobile-">5 Mobile设备</h1>
<p><em>engine.get_device()</em>类device提供与手机相关信息的API，也提供简单的操作。示例：sample/devices_tester.py</p>
<p><a name="5.1"></a></p>
<h2 id="5-1-">5.1 屏幕尺寸与转向</h2>
<pre><code class="lang-python">def test_get_display_size():
    display_size=device.get_display_size()
    logger.debug(display_size)

    rotation=device.get_rotation()
    logger.debug(&quot;Rotation : {0}&quot;.format(rotation))

test_get_display_size()
</code></pre>
<p>获取屏幕尺寸，DisplaySize类包括width、height单位为px。</p>
<p><img src="image/device_screen.png" alt="Drawing" width="600px" /></p>
<p><a name="5.2"></a></p>
<h2 id="5-2-package-activity">5.2 顶层Package与Activity</h2>
<pre><code class="lang-python">def test_get_top_package_activity():
    top_activity=device.get_top_package_activity()
    logger.debug(top_activity)

test_get_top_package_activity()
</code></pre>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<pre><code class="lang-bat">python devices_tester.py
</code></pre>
<p><em>device.get_top_package_activity()</em>获取手机当前界面的TopActivity对象，包含顶层app的包名和Activity名称。</p>
<pre><code>package name = com.tencent.wetest.demo,activity = com.unity3d.player.UnityPlayerActivity
</code></pre><p><a name="5.3"></a></p>
<h2 id="5-3-">5.3 回退键</h2>
<p>wpyscripts不提供对标准Android控件的支持，所以当界面上出现标准控件时将无法进行操作。因此，提供了回退（Back）操作，返回到游戏Activity。</p>
<pre><code class="lang-python">def test_back():
    device.back()
test_back()
</code></pre>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<pre><code class="lang-bat">python devices_tester.py
</code></pre>
<p><em>device.back()</em>与按Android的回退键效果一致。</p>
<p><a name="6"></a></p>
<h1 id="6-">6 云端报告</h1>
<p><em>engine.get_reporter()</em>获取的Reporter类封装了与云端报告相关的内容，本地实现为空，只有在云端运行的时候才会有效果。游戏自动化测试过程中需要保持测试现场，所以在云端运行过程中需要标记测试过程和截图。Reporter主要负责与功能</p>
<pre><code class="lang-python">import sys, os, time

#sys.path.append(os.path.abspath(os.path.join(os.getcwd(), &quot;..\\&quot;)))

import wpyscripts.manager as manager

engine = manager.get_engine()
logger = manager.get_logger()
reporter = manager.get_reporter()


def screen_shot_click(element):
    logger.debug(&quot;screen_shot_click&quot;)
    if element is None:
        return
    bound = engine.get_element_bound(element)
    logger.debug(bound)
    pos_x = bound.x + bound.width / 2
    pos_y = bound.y + bound.height / 2
    reporter.capture_and_mark(pos_x, pos_y, locator_name = element.object_name)
    engine.click_position(pos_x, pos_y)


def enter_find_elmeents():
    find_elements_button = engine.find_element(&quot;/Canvas/Panel/FindElements&quot;)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(1)

def back_main():
    find_elements_button = engine.find_element(&quot;/Canvas/Panel/Back&quot;)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(1)

def test_capture_and_mark():
    elements = engine.find_elements_path(&quot;/Canvas/Panel/VerticalPanel/Item(Clone)&quot;)
    for element in elements:
        screen_shot_click(element)
        time.sleep(2)

def test_reporter():
    print(&quot;test_reporter&quot;)
    enter_find_elmeents()
    time.sleep(2)
    reporter.add_start_scene_tag(&quot;Find_Scene&quot;)
    test_capture_and_mark()
    reporter.add_end_scene_tag(&quot;Find_Scene&quot;)
    time.sleep(2)
    back_main()
    reporter.screenshot()
</code></pre>
<p>runner.py里面，调用test_reporter()。上传到平台后的结果的运行结果（同事在几百台手机上运行）</p>
<pre><code class="lang-python">import traceback

try:
    from sample.reporter_tester import *
except Exception,e:
    traceback.print_exc()

def run():
    &quot;&quot;&quot;
        业务逻辑的起点
    &quot;&quot;&quot;
    try:
        test_reporter()
    except Exception,e:
        traceback.print_exc()
        stack=traceback.format_exc()
        logger.debug(stack)
</code></pre>
<p><img src="image/reporter_screen.png" alt="Drawing" width="600px" /><br><img src="image/reporter_perform.png" alt="Drawing" width="600px" /></p>
<p><a name="6.1"></a></p>
<h2 id="6-1-">6.1 截图与操作过程标记</h2>
<pre><code class="lang-python">def screen_shot_click(element):
    logger.debug(&quot;screen_shot_click&quot;)
    if element is None:
        return
    bound = engine.get_element_bound(element)
    logger.debug(bound)
    pos_x = bound.x + bound.width / 2
    pos_y = bound.y + bound.height / 2
    reporter.capture_and_mark(pos_x, pos_y, locator_name = element.object_name)
    engine.click_position(pos_x, pos_y)
</code></pre>
<p><em>reporter.capture_and_mark(pos_x, pos_y, locator_name = element.object_name)</em>将会截取当前手机屏幕，并在pos_x,pos_y位置标记一个红点。</p>
<p><img src="image/screen_mark.jpg" alt="Drawing" width="400px" /></p>
<p><a name="6.2"></a></p>
<h2 id="6-2-">6.2 截图</h2>
<p><em>reporter.screenshot()</em>在云端会截图在报告里面体现，在本地运行时会截图并放在运行目录下的screenshot目录下面。</p>
<p><a name="6.3"></a></p>
<h2 id="6-3-">6.3 打标签</h2>
<pre><code class="lang-python">reporter.add_start_scene_tag(&quot;Find_Scene&quot;)
reporter.add_end_scene_tag(&quot;Find_Scene&quot;)
</code></pre>
<p><em>reporter.add_start_scene_tag(&quot;&quot;)和reporter.add_end_scene_tag(&quot;&quot;)</em>一定是成对出现的，先start然后end，里面的标签内容需要一样。</p>
<p><img src="image/tag.png" alt="Drawing" width="600px" /></p>
<p><strong>注：配合engine.get_scene()效果更佳</strong></p>
<p><a name="7"></a></p>
<h1 id="7-">7 定制功能</h1>
<p>GAutomatorView不可能集成所有的功能，部分功能也不方便通过简单的触屏操作完成，或者通过触屏操作完成的复杂度极高。定制功能，可以向WeTest SDK注册委托，通过python脚本来触发委托的执行，并将结果返回给python脚本。<br>该功能需要游戏开发者和游戏测试者协同完成<br>1、游戏中注册，自定义函数<br>2、自动化脚本，调用自定义函数<br><a name="7.1"></a></p>
<h2 id="7-1-unity-">7.1 Unity游戏端注册委托</h2>
<p>Unity游戏开发者需要，注册对应的函数供脚本调用，如完成英雄位移等</p>
<pre><code class="lang-C#">using UnityEngine;
using System.Collections;
using WeTest.U3DAutomation;

public class CustomTester : MonoBehaviour {
    void Start () {

        Debug.Log(&quot;Register test&quot;);
        WeTest.U3DAutomation.CustomHandler.RegisterCallBack(&quot;test&quot;, testReq);
    }

    string testReq(string args)
    {
        Debug.Log(&quot;Args = &quot; + args);
        string result = args + &quot; Response&quot;;
        return result;
    }

    void OnDestroy()
    {
        Debug.Log(&quot;UnRegister test&quot;);
        CustomHandler.UnRegisterCallBack(&quot;test&quot;);
    }
}
</code></pre>
<p><em>WeTest.U3DAutomation.CustomHandler.RegisterCallBack(&quot;test&quot;, testReq)</em>:主要一个注册的函数的名称和一个函数。注册了这个函数之后，脚本执行时如果发送执行test，SDK就会调用testReq（string arg）这个函数，并把脚本发送过来的内容作为string参数传入。函数返回结果会返回给脚本端。<br><em>CustomHandler.UnRegisterCallBack(&quot;test&quot;)</em>:将函数从注册表中移除。</p>
<p><a name="7.2"></a></p>
<h2 id="7-2-">7.2 脚本调用</h2>
<p>wpyscripts能够直接调用游戏中的注册函数，并获取返回值。<strong>示例：sample/self_define_fun.py</strong><br><a name="7.2.1"></a></p>
<h3 id="7-2-1-">7.2.1 获取可执行委托</h3>
<p><em>engine.get_registered_handlers()</em>可以获取当前可以用的注册名单</p>
<pre><code class="lang-python">def test_get_registered_handlers():
    result = engine.get_registered_handlers()

    for name in result:
        logger.debug(name)

test_get_registered_handlers()
</code></pre>
<p>确保wetest_demo.apk在拉起来的界面</p>
<pre><code class="lang-bat">python self_define_fun.py
</code></pre>
<p>运行后，可以获取当前，注册的函数为&quot;test&quot;</p>
<p><a name="7.2.2"></a></p>
<h3 id="7-2-2-">7.2.2 执行委托</h3>
<p><em>engine.call_registered_handler(&quot;test&quot;, &quot;python call test&quot;)</em>:可以调用SDK中注册的委托</p>
<pre><code class="lang-python">def test_call_registered_handler():
    result = engine.call_registered_handler(&quot;test&quot;, &quot;python call test&quot;)
    logger.debug(result)

test_call_registered_handler()
</code></pre>
<p>确保wetest_demo.apk在拉起来的界面</p>
<pre><code class="lang-bat">python self_define_fun.py
</code></pre>
<p>运行&quot;test&quot;关键词对应的注册的委托，传入参数为&quot;python call test&quot;。获取委托执行后的返回值&quot;python call test Response&quot;</p>
<p><a name="7.2.3"></a></p>
<h3 id="7-2-3-">7.2.3 获取组件上的方法</h3>
<p>可以获取到游戏中的GameObject上某个Component上的public方法信息，包括方法名称，方法需要的参数和返回的类型。在wetest_demo.apk中，Sample按钮上挂载了ReflectionTest组件，可以使用下面代码返回该组件中的方法。</p>
<pre><code class="lang-python">def test_get_component_methods(self):
    element = self.engine.find_element(&quot;Sample&quot;)
    methods = self.engine.get_component_methods(element, &quot;ReflectionTest&quot;)
    logger.debug(methods)
</code></pre>
<p>上面的代码在sample/interaction.py中，运行该函数可以获得全部的public方法。</p>
<p><a name="7.2.4"></a></p>
<h3 id="7-2-4-">7.2.4 调用组件上的方法</h3>
<p>通过反射可以调用GameObject某个组件上的public方法，并获得返回值。调用时需要传入组件名称、方法名称和参数列表。wetest_demo.apk中调用Sample按钮ReflectionTest组件上的TestReflection方法（需要两个参数int,string,返回int值），调用代码如下：</p>
<pre><code class="lang-python">def test_call_component_method(self):
    element = self.engine.find_element(&quot;Sample&quot;)
    params = []
    params.append(5)
    params.append(&quot;Hello World&quot;)
    result = self.engine.call_component_method(element, &quot;ReflectionTest&quot;, &quot;TestReflection&quot;, params)
    logger.debug(result)
</code></pre>
<p>上面的代码在sample/interaction.py中，将调用游戏中的TestReflection方法，并返回105（方法的返回值）。</p>
<p><a name="7.3"></a></p>
<h3 id="7-3-">7.3 反射获取游戏中属性值</h3>
<p>在使用自动化测试过程中，定制一些高级功能时，现有的接口获取的数据可能无法满足需求。如，希望根据英雄血量来定制策略。因此，GAutomator提供了一个高级接口，通过反射的方式获取游戏中组件里面的属性值。<em>get_component_field(element,component,attribute)</em>接口可以获取GameObject上组件对应的属性值</p>
<pre><code class="lang-python">def test_get_component_field(self):
        elements = self.engine.find_elements_path(&quot;Sample/Text&quot;)
        self._start()
        res = self.engine.get_component_field(elements[0], &quot;Text&quot;, &quot;text&quot;)
        self._end(&quot;get_component_field&quot;)
        self.assertEqual(res, &quot;Sample&quot;)

        e = self.engine.find_element(&quot;Panel&quot;)
        res = self.engine.get_component_field(e, &quot;MainControl&quot;, &quot;bollon&quot;)
        self.assertEqual(res, &quot;Bollon (UnityEngine.RectTransform)&quot;)
</code></pre>
<p>确保wetest_demo.apk在拉起来的界面，运行结果可以看到获取了Sample/Text GameObject上面组件Text中对应text属性的值为Sample。GAutomator获取到组件属性后，会直接调用toString()转换为string字符串。如果属性本身也是Object，toString()之后的值可能意义并不会特别大如（Bollon (UnityEngine.RectTransform)）。现在暂时未提供级联的操作，无法获取对象Bollon上的属性值。</p>
<p><a name="7.4"></a></p>
<h3 id="7-4-camera">7.4 设置最佳渲染Camera</h3>
<p>Unity里面一个物体可能会被多个Camera渲染，如有一个主摄像机还会有光晕渲染等摄像机。WeTest SDK中会寻找一个最佳的Camera，但是有的时候可能找到的Camera并不准确。具体表现为，渲染的物体大小及位置不准确，可能是远大于实际的长宽。<br>GAutomatorView查看物体，发现长宽高不对时。可以使用set_camera设置其他相机，然后再用GAutomatorView尝试看是否恢复正常，恢复正常了则该GameObject为最适合的摄像机。engine中<em>et_camera(gameobject_name)</em>：设置Camera所在的gameobject名称。</p>
<pre><code class="lang-C#">engine.set_camera(&quot;CharModeCamera&quot;)
</code></pre>
<p>设置Camera后，如果物体渲染的Camera中包含设置的Camera，则会直接采用设置的Camera。<a href="https://docs.unity3d.com/ScriptReference/Camera.html" title="UnityCamer资料">UnityCamera资料</a></p>
<p><a name="8"></a></p>
<h1 id="8-">8 实战用例</h1>
<p>举例最常见的，较难处理的引用场景scripts/testcase/tools.py封装了，场景的使用场景</p>
<p><a name="8.1"></a></p>
<h2 id="8-1-">8.1 摇杆</h2>
<p>MOBA游戏越来越流行，摇杆类游戏区别需要滑动和按压连续操作。Wpyscripts提供了专门针对摇杆类动作的封装<em>engine.swipe_and_press(start_x, start_y, end_x, end_y, steps, duration, step_sleep=5)</em>能够实现，对大部分摇杆的操作。实例位置sample/joystick_tester.py</p>
<pre><code class="lang-python">def convert_pos(x, y):
    display_size = device.get_display_size()
    return x * display_size.width, y * display_size.height

def test_swipe_and_press():
    time.sleep(2)
    start_time=datetime.datetime.now()
    start_x,start_y=convert_pos(0.1197916,0.796296)
    end_x,end_y=convert_pos(0.1197916,0.69444)
    engine.swipe_and_press(start_x,start_y,end_x,end_y,100,10000)

    logger.debug(&quot;Use time : {0}&quot;.format(datetime.datetime.now()-start_time))
    time.sleep(3)

test_swipe_and_press()
</code></pre>
<p>上面的代码可以保存为joystick_tester.py,点击JoyStick按钮，进入摇杆操作界面</p>
<pre><code class="lang-bat">python joystick_tester.py
</code></pre>
<ul>
<li><code>start_x,start_y</code>,表示滑动的起始位置</li><li><code>end_x,end_y</code>,表示滑动的结束位置</li><li><code>steps</code>，表示滑动中间经过的步骤数，每一步的时间约为5ms。滑动的步骤数控制着滑动的速度和平滑度</li><li><code>step_sleep</code>:每个步骤的间隔时长，单位毫秒</li><li><code>duration</code>，结束位置按压时间，单位是毫秒ms</li></ul>
<p><a name="8.2"></a></p>
<h2 id="8-2-">8.2 记录操作流程</h2>
<p>自动化测试记录操作流程，有利于出现bug时定位和复现。所以原则上，应该记录每一步操作。tools.py里面封装了一个接口，能够在截图上标记点击的位置，然后执行点击操作，点击完成等待相应的时间。</p>
<ul>
<li><p>screen_shot_click(element,sleeptime)接口,传入需要点击的节点和点击后等待时间。</p>
<pre><code class="lang-python">def screen_shot_click(element, sleeptime=2):
  &quot;&quot;&quot;
      点击，并标记红点。
  :param element: 需要点击的element
  :param sleeptime:
  :return:
  &quot;&quot;&quot;
  if element is None:
      return
  try:
      bound = engine.get_element_bound(element)
  except WeTestRuntimeError, e:
      bound = None
  if not bound:
      return
  logger.debug(bound)
  pos_x = bound.x + bound.width / 2
  pos_y = bound.y + bound.height / 2
  logger.debug(&quot;screen_shot_click_pos x = {0},y = {1},name = {2}&quot;.format(pos_x, pos_y, element.object_name))
  report.capture_and_mark(pos_x, pos_y, locator_name=element.object_name)
  engine.click_position(pos_x, pos_y)

  time.sleep(sleeptime)
</code></pre>
<p>传入的element为空或者element的位置找不到，则自动跳过。</p>
<pre><code class="lang-python">qq_button = engine.find_element(&quot;/BootObj/CUIManager/Form_Login/LoginContainer/pnlMobileLogin/btnGroup/btnQQ&quot;)
screen_shot_click(qq_button, 6)
</code></pre>
</li></ul>
<p><a name="8.3"></a></p>
<h2 id="8-3-qq-">8.3 QQ或微信登录</h2>
<p>QQ或者微信登录，设计到Activity的切换和Android标准控件的操作,操作过程复杂，但是相对较为固定。在云端运行时，每次拉起游戏之前，都会清理数据，所以每次都需要重新登录。每次登录的过程如下所示：</p>
<p><img src="image/login_step.png" alt="Drawing" width="600px" /><br>对应的处理代码如下所示：</p>
<pre><code class="lang-python">def login():
    # 步骤1，等待到达登录界面
    wait_for_scene(&quot;SceneName&quot;)

    # 选择QQ登陆
    qq_button = find_elment_wait(&quot;/BootObj/Panel/btnQQ&quot;)
    screen_shot_click(qq_button, 6)

    #步骤2 ，等待进入QQ登录界面，packagename为com.tencent.mobileqq，如果是微信登录界面package为com.tencent.mm
    wait_for_package(&quot;com.tencent.mobileqq&quot;)
    device.login_qq_wechat_wait(120)
    time.sleep(10)

    #步骤3，等待QQ登录界面退出，切换到游戏界面
    select_btn = find_elment_wait(&quot;/BootObj/Panle/selectBtn&quot;)
</code></pre>
<ol>
<li>步骤1：等待进入到登录选择scene，如何获取scene名称，请看<a href="#1.4">1.4 GAutomatorView</a>。wait_for_scene(&quot;SceneName&quot;)，会一直查询，直到进入名称为&quot;SceneName&quot;的场景。进入到&quot;SceneName&quot;的场景后，查询QQ登录按钮直到出现(find_elment_wait)，并点击QQ登录按钮。</li><li>步骤2：从游戏的Activity切换到QQ或者微信的登录界面需要一定的时间。<code>wait_for_package(&quot;com.tencent.mobileqq&quot;)</code>检查顶层包名，直到QQ的顶层包名(微信包名为com.tencent.mm)。<code>device.login_qq_wechat_wait(120)</code>会根据当前的顶层包名，自动选择QQ或者微信登录，当顶层包名不再是&quot;com.tencent.mm&quot;或&quot;com.tencent.mobileqq&quot;时推出。<br><strong>注：账号由云端自动分配。本地调试时请修改wpyscripts/wetest/device.py下面<code>native_deivce.__init__(self)</code>中的账号密码</strong></li><li>步骤3：等待进入游戏界面，直到出现某个element为止。</li></ol>
<p><a name="8.4"></a></p>
<h2 id="8-4-">8.4 战斗场景随机操作</h2>
<p>进入战斗场景后，我们通常可以在里面进行随机操作，直到比赛结束。scripts/testcase/tools.py里面封装了一个random_click(fun=None, forbid_elements=(),max_num=1000,sleep = 2)</p>
<pre><code class="lang-python">def random_click(fun=None, forbid_elements=(),max_num=1000,sleep = 2):
    &quot;&quot;&quot;
        随机点击界面上的可操作控件。
    :param fun: 如果fun调用返回True，则随机点击结束
    :param forbid_elements: 禁止点击的组件列表(如退出键)
    :param max_num:最大点击次数
    :param sleep:每次点击后的睡眠时间
    :return:
    &quot;&quot;&quot;
    logger.debug(&quot;Random click&quot;)
    elements = engine.get_touchable_elements()
    for i in range(max_num):
        if elements is None or len(elements) &lt;= 0:
            time.sleep(1)
            elements=engine.get_touchable_elements()
            continue
        if fun and fun(elements):
            logger.info(&quot;Find need elements&quot;)
            return
        elements = filter(lambda e: e[0].object_name not in forbid_elements,elements)
        e,pos = find_less_click_element(elements)
        if pos is None:
            continue
        screen_shot_click_pos(pos[&quot;x&quot;], pos[&quot;y&quot;], e.object_name)
        time.sleep(sleep)
        elements = engine.get_touchable_elements()
</code></pre>
<p><img src="image/fight_random_click.png" alt="Drawing" width="600px" /></p>
<p>上面王者荣耀这个游戏，进入游戏战斗场景后，就可以随意操作界面里面的按钮（除了暂停），如技能、英雄切换、攻击。如果，比赛胜利，则会弹出&quot;点击屏幕继续&quot;这个element。</p>
<pre><code class="lang-python">def get_condition_fun(*name):
    &quot;&quot;&quot;
        主要用于random_click，传入一系列的elements，只要可点击的节点里面有符合的就返回

        应用场景：需要点击某个节点，但是在该界面可能出现弹出框。弹出框不确定的情况下，可以使用
    :param name:
    :return:
    &quot;&quot;&quot;
    def find_need_element(elements):
        for e,pos in elements:
            if e.object_name in name:
                logger.info(&quot;Find element name {0}&quot;.format(e.object_name))
                return True
        return False

    return find_need_element

# 比赛随机点
random_click(get_condition_fun(&quot;/Root/Panel/ContinueBtn&quot;),
                         (&quot;/Root/Pause/Button&quot;))
</code></pre>
<p>可点击的节点中出现&quot;/Root/Panel/ContinueBtn&quot;则random_click退出。界面中的&quot;/Root/Pause/Button&quot;不需要进行点击。<br>random_click()会优先点点击次数最少的按钮。</p>
<p><a name="8.5"></a></p>
<h2 id="8-5-">8.5 选区操作</h2>
<p>所有账户需要进入指定服务器，需要选区（大部分情况下，区按钮Element名称是一样的）。选区可以巧妙的利用find_elements_path()来点击指定的服务器。</p>
<p><img src="image/select_section.png" alt="Drawing" width="600px" /></p>
<pre><code class="lang-python">def select_section():
    &quot;&quot;&quot;
        选区
    :return:
    &quot;&quot;&quot;
    select_btn = find_elment_wait(&quot;/Root/pnlStartGame/Panel&quot;)
    screen_shot_click(select_btn, 5)

    servers = engine.find_elements_path(
        &quot;/Root/Form_Login/ZoneContainer/ScrollRect/Content/*{txt=1区-10区}&quot;)
    if len(servers) &gt; 0:
        screen_shot_click(servers[0], 3)

    old_server = engine.find_elements_path(
        &quot;/Root/Form_Login/ZoneContainer/ScrollRect/Content/*{txt=手Q1区 王者独尊}&quot;)
    if len(old_server) &gt; 0:
        screen_shot_click(old_server[0], 4)

    start_game_button = find_elment_wait(&quot;/Root/Form_Login/ZoneContainer/ScrollRect/Content/btnStartGame&quot;)
    screen_shot_click(start_game_button, 10)
</code></pre>
<p>充分利用engine.find_elements_path()中的txt查找功能，找到指定的服务器。</p>
<p><a name="8.6"></a></p>
<h2 id="8-6-">8.6 自动化探索遍历</h2>
<p>用户除了编程实现游戏的各类操作外，还可以直接调用<strong>wpyscripts</strong>框架提供的方法，进行界面的自动化探索遍历测试。示例代码<strong>sample/travel_tester.py</strong></p>
<pre><code class="lang-python">def test_travel():
    &quot;&quot;&quot;
    :param statfilename: 探索遍历测试完成后生成的统计信息文件名，建议保持&quot;policy.log&quot;不变
    :param forbid_elements: 禁止点击的组件列表(如退出键)
    :param mode: 新老两种模式的选项，建议保持为0不变
    :param max_num: 自动化探索遍历的总点击次数
    :return:
    &quot;&quot;&quot;
    travel.explore(&quot;policy.log&quot;, [], mode=0, max_num=30)

test_travel()
</code></pre>
<p>运行这个方法，travel.explore函数就会自动遍历。禁止按钮如果没有的话可以不传。<br>利用这个方法，用户不用编写任何逻辑代码，<strong>wpyscripts</strong>框架就会探索遍历游戏的各个界面，并尽可能的点击每一个界面按钮</p>
<p><a name="8.7"></a></p>
<h2 id="8-7-">8.7 异常处理</h2>
<p>对于GAutomator的异常处理是一件非常头痛的事情，在设计框架的过程中也是左右为难，本质原因在于手机的端的不稳定性。不稳定主要包括以下几方面：</p>
<ol>
<li>adb不稳定:windows的adb及其不稳定长期连接过程中不可避免的会出现断开连接的情况。出现断开的情况在腾讯可能有应用宝tadb.exe端口抢占、IOA、QQ浏览器及其他所有手机助手。wetest平台重写了adb，并且运行在linux之上稳定性好很多。adb断开连接，不可恢复，脚本退出。</li><li>游戏不稳定:SDK部分与UI相关的内容运行在UI主线程，当游戏暂停时可能会出现timeout的情况。如，QQ登录按钮跳转到登录界面，分享按钮，游戏会退出前台主线程暂停。</li><li>UIAutomator不稳定：UIAutomator并不是一个非常稳定的服务，可能会出现操作无效的情况。</li></ol>
<p>框架本身，只要是框架处理不了的异常，都会抛给调用者。</p>
<ol>
<li>测试编写的过程中，如果出现操作的内容，可能会让游戏退出前台engine相关接口尽量catch。</li><li>对于操作可有可无的，也尽量catch。如点击操作不影响测试流程，如攻击按钮，可以选择catch</li></ol>
<p><a name="9"></a></p>
<h1 id="9-">9 实际使用接口</h1>
<p>GAutomator主要的大三类接口engine,reporter，device属于颗粒度非常细的接口，尽可能的原子化，但是直接使用这部分内容进行开发的话，并不是一件容易的事情。所以，根据在实际项目中使用的经验，我们封装了一些更加方便的、易于使用、不容易出错的接口，供开发人员快速的开发出稳定有效的测试用例。<br><a name="9.1"></a></p>
<h2 id="9-1-screen_shot_click-">9.1 screen_shot_click 点击控件截图并记录轨迹</h2>
<p>在使用过程中该接口基本，可以替代GameEngine.click。操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间，这个操作过程是比较理想的，也是一个最基本的操作。<br>wetest平台截图的速度非常快，对性能影响也极低，可以对每一个操作步骤均进行截图。<br><em><code>screen_shot_click(element, sleeptime=2, exception=False)</code></em><br>element:可以为Element实例，也可以为需要点击的name<br>sleeptime:点击完成后sleep的时间<br>exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False</p>
<p>example:</p>
<pre><code class="lang-python">from testcase.tools import *

button=engine.find_element(&quot;LoginQQ&quot;)
screen_shot_click(button,sleeptime=5,exception=True)

screen_shot_click(&quot;Attack&quot;,sleeptime=0)
</code></pre>
<p>截图并标记轨迹如下所示，该部分功能仅限wetest平台测试有效：</p>
<p><img src="image/screen_mark.jpg" alt="Drawing" width="400px" /></p>
<p><a name="9.2"></a></p>
<h2 id="9-2-screen_shot_click_pos-">9.2 screen_shot_click_pos 点击位置截图并记录轨迹</h2>
<p>screen_shot_click_pos与screen_shot_click的区别是，一个点击的是UI控件，一个纯粹是位置信息。操作流程两个是一致的，操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间。<br><em><code>screen_shot_click_pos(pos_x,pos_y, sleeptime=2, exception=False)</code></em><br>pos_x:x坐标位置<br>pos_y:y坐标位置<br>sleeptime:点击完成后sleep的时间<br>exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False</p>
<p><a name="9.3"></a></p>
<h2 id="9-3-find_elment_wait-">9.3 find_elment_wait查找控件直到出现位置</h2>
<p>游戏对于操作的反应时间，在不同的手机上差别可能会非常大。开始游戏登录服务器到大厅加载完成，加载过程跟网络情况、手机性能都有关系，如果仅仅使用sleep来控制的话，时间长了可能会效率低下，时间短了可能会让测试失败。所以，我们提供了find_element_wait，方便用户更加精确的控制测试进度。如，点击开始游戏后，就一直查找大厅界面的某个UI控件，查找到了也代表大厅界面加载完成了。<br><em><code>find_elment_wait(name, max_count=10, sleeptime=3)</code></em><br>name:需要查找的控件名称<br>max_count:尝试查找，调用engine.find_element的最大次数<br>sleeptime:每次调用engine.find_element的间隔时间。max_count*sleeptime约等于最大等待市场</p>
<p>example</p>
<pre><code class="lang-python">from testcase.tools import *

start_game_button = find_elment_wait(&quot;btnStartGame&quot;)
screen_shot_click(start_game_button, 5)

pve_btn=fine_element_wait(&quot;PveBtn&quot;,max_count=20,sleeptime=2)
screen_shot_click(pve_btn)
</code></pre>
<p>登录完成后，等待开始游戏按钮出现，点击开始游戏后游戏需要加载一段时间，直到PVE的按钮出现后点击PVE按钮。</p>
<p><a name="9.4"></a></p>
<h2 id="9-4-wait_for_scene-">9.4 wait_for_scene等待某个场景加载完毕</h2>
<p>开始进入对局到真正进入战斗场景，通常会有一段时间，这个时候通常可以用wait_for_scene来判断是否进入。wait_for_scene与find_elment_wait的区别是，一个等待Element出现，一个是等待Scene（Unity的Scene，通过GAutomatorView能查看）出现。</p>
<p>example</p>
<pre><code class="lang-python">from testcase.tools import *

#等待加载界面出现，如王者荣耀5v5匹配到后的加载界面
wait_for_scene(&quot;Loading&quot;, times=40)

#等待加载界面的控件已经产生
find_elment_wait(&quot;Form_Loading&quot;, max_count=30)

#等待加载界面的显示控件消失。不能用find_element_wait战斗场景某个控件的方式。loading的时候已经在生成element
while True:
   loading = engine.find_element(&quot;Form_Loading&quot;)
   if loading:
      time.sleep(5)
   else:
      logger.debug(&quot;Load Over&quot;)
      break
</code></pre>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
